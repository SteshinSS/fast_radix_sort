I have written `boost::spreadsort`-like sort, but it works 40% faster. The russian post is about how I did it.

# Сделаем spreadsort быстрым снова
## Задача
`Boost::spreadsort` -- это гибридный алгоритм in-place сортировки. Он запуксает radix/bucket-sort и переходит на `std::sort`, когда массив мал. Я реализовал ту же идею, но улучшил производительность. 

Всегда есть соблазн написать быстрый код, сузив исходную задачу. Я постарался сохранить универсальность кода и, по-моему, немного увеличил ее. Формально, я пишу сортировку, которая, как и `spreadsort`:
- in-place
- non-stable
- single-thread
- реализует идею radix-sort

Я прочитал код `boost::spreadsort` и заметил еще несколько ограничений. Буст использует старшие биты ключа в качестве номера бакета. Это значит, что алгоритм расчитывает на равномерное распределение ключей. Именно на таких ключах я смог повторить результат из вики: двухкратное ускорение, по сравнению с `std::sort`. И еще: чтобы ускорение вышло именно за счет поразрядной сортировки, мы не будем использовать никакую сортировку, кроме `std::sort`.
- равномерное распределение ключей
- можно использовать только `std::sort`

`boost::spreadsort` имеет еще одну особенность: код имеет оптимизации на случай узкого диапазона ключей. Мы можем считать диапазон полным и тогда сразу выиграем 10%, убрав ненужную проверку. Хоть это облегчает задачу, я сохранил эту особенность. Поэтому сравнивать мы будем на рандомном ограниченном диапазоне.
- ограниченный диапазон

Всегда можно выиграть, затачиваясь под свое железо. Для честного сравнения я сначала вручную поигрался с параметрами `spreadsort`, а потом запустил оптимизированный монте-карло поиск самых эффективных параметров. Через полтора часа и 20'000 итераций, я нашел несколько хороших наборов, но они почти не отличались от стандартных, поэтому я ничего не менял.

## Первый результат
![In Cache 1'000'000](InCache1M.png)
![Boost::SpreadSort 1'000'000](Boost1.png)

Я замерил время сортировки 1'000'000 32-битных интов. Слева моя версия, справа -- `Boost::Spreadsort`. Если открыть картинки отдельно, будет видна подпись. На глазок -- ускорение 30%. В отличие от хитрого буста, моя версия работает в лоб: всегда разбивает на одинаковое количество бакетов. Зато в исходном алгоритме был небольшой недостаток: `Spreadsort` находил максимальный и минимальный элементы, разбивал диапазон между ними на равномерные бакеты, заполнял их и рекурсивно запускался на каждом бакете. Алгоритм использовал старшие биты для распределения между бакета, поэтому мы можем вычислить диапазоны ключей в бакетах. Я стал это учитывать и искал максимальный и минимальный элементы только на первой итерации. Это не сработает при неравномерное распределении ключей, но тогда не сработает и partition-функция буста.

Результат неплохой, но это скорее проблемы `Boost::Spreadsort`, чем моя заслуга. Я не стал выкладывать результаты тестирования на 10'000'000 чисел. На них моя версия работает немного медленней быстрейших 90%, зато не имеет выбросов, которые случаются у буста при широком диапазоне ключей. Тогда он замедляется в два раза. Я думаю, это проблема partition-функции и алгоритма, который выбирает количество бакетов.

Я получил ускорение, но можно ли еще быстрей?
